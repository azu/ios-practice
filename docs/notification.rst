UILocalNotificationを使った通知の設定について
==============================================================

``UILocalNotification`` を使ったローカル通知の設定方法について

設定済みの通知をキャンセルしてから設定し直す
--------------------------------------------------------------

ローカル通知が重複して登録されてしまうことがあるため、基本的に設定済みのローカル通知をキャンセルしてから
通知を設定し直した方が管理が楽になります。(複数の通知がある場合はそれを設定し直す)

.. code-block:: objc

	[[UIApplication sharedApplication] cancelAllLocalNotifications];

通知を設定する期間の問題
--------------------------------------------------------------

アプリによって設定する通知は時間や繰り返しなど様々だと思いますが、
遠い未来や無限に繰り返す内容の通知をそのまま設定するのは無理がでてきます。

そのため、現在の情報をもとに1週間から1ヶ月程度の範囲に通知だけを設定する等の制限を設けたほうがいいと思います。
(これは上記の毎回キャンセルしてから設定するのと相性がいいです)

そして、アプリを起動 or 終了 した時などに、通知を設定し直すことで、
ずっと放置してる場合は通知がでなくなりますが、使っている人に対しては通知が継続されるような仕組みが自然とできると思います。


通知の発火時間をチェックしてから通知の設定を行う
--------------------------------------------------------------

ローカル通知を設定する際は、必ず通知の ``fireDate`` プロパティが、現在時間より後なのかを
確認してから設定するべきです。

現在時間より前に通知を設定すると、設定した瞬間に通知が発火してしまいます。

:file:`/Code/ios-practice/LocalNotification/LocalNotificationManager.m`

.. literalinclude:: /Code/ios-practice/LocalNotification/LocalNotificationManager.m
  :language: objc



通知を設定するのはいつ?
-----------------------------------------------------------------

ローカル通知は必ず、通知を管理するクラスを経由して設定すべきですが、
いつ設定するのがいいのかという問題もあります。
(毎回、UILocalNotificationを書くのはバッドプラクティスだと思います)

データを保存した際に通知を設定すると、保存するコードごとに通知について書かないといけなくなる事や、
"設定済みの通知をキャンセルしてから設定し直す" というパターンとも相性があまり良くありません。

比較的シンプルに書けるのが、アプリがバックグラウンドに行く時に設定するパターンです。

.. code-block:: objc

    - (void)applicationDidEnterBackground:(UIApplication *)application {
        // 通知の設定クラスを呼び出す
    }

メリットとしては、同期的に通知を設定してもUIスレッドに対しての影響が少ない事や、
アプリのライフサイクル的に、大体の場合はここを通るので、保存するごとに通知を設定しないで、
``applicationDidEnterBackground`` のみで設定すればよくなるためコードもシンプルになります。

デメリットとして、アプリ表示中にローカル通知を受け取って表示する( ``application:didReceiveRemoteNotification:`` )など、
保存した時にローカル通知を付けないといけないような条件があるときには利用できないパターンです。

別スレッドで通知を設定する場合
-----------------------------------------------------------------

ローカル通知の設定は同期的に行われるので大量に設定する場合は、dispatch_async等を使い、
UIが固まらないように設定すればいいです。

.. code-block:: objc

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 通知を設定する処理
        dispatch_async(dispatch_get_main_queue(), ^{
            /* メインスレッドでのみ実行可能な処理 */
        });
    });

しかし、バックグラウンドで設定する際、通知を設定する基準を決めるデータを取るために、
CoreData等スレッドセーフではないもの等を触る時に問題が起きやすいことがあります。

そのような場合は、同期的に設定できてUIスレッドを意識しないでシンプルに行える、バックグラウンド時がお手軽です。